file.CreateDir( "buildr" )
for _, d in pairs( { "builds", "builds/rhud", "builds/rim", "builds/lua", "saves" } ) do
	file.CreateDir( "buildr/" .. d )
end

local lua_base = [[local HUD = { materials = {} }

function HUD:CreateFont( name, font, size, t )
	t.font = font
	t.size = size
	surface.CreateFont( name, t )
end

function HUD:CreateAvatar( size )
	self.Avatar = vgui.Create( "AvatarImage" )
		self.Avatar:SetPlayer( LocalPlayer(), size or 64 )
		self.Avatar:SetName( "RHUD_Avatar" )
		self.Avatar:ParentToHUD()
		self.Avatar:SetVisible( false )
end
		
function HUD:PaintAvatar()
	self.Avatar:SetPaintedManually( false )
	self.Avatar:PaintManual()
	self.Avatar:SetPaintedManually( true )
end]]

local lua_hook = [[hook.Add( "InitPostEntity", HUD, HUD.Init )
hook.Add( "HUDPaint", HUD, function()
	if uses_avatar and not HUD.Avatar then HUD:CreateAvatar() end
	HUD:Draw()
end )]]

local formats = {
	rhud = {
		base = {
			"local HUD = RHUD:CreateHud()\nHUD.Name = \"%s\"",
			"HUD.Author = \"%s\"",
			"HUD.UsesAvatar = %s",
			"%s",
		},
		function_name = "function HUD:%s()",
		terminator = "end",
		scr = "()",
		start = 2,
		finalize = function( code, name )
			local files = file.Find( "buildr/builds/rhud/*.txt", "DATA" )
				file.Write( "buildr/builds/rhud/" .. name .. ".txt", code )
			return "builds/rhud/" .. name .. ".txt"
		end,
	},
	rim = {
		base = {
			">>Name = %s",
			">>Author = %s",
			"uses_avatar = %s",
			"%s",
		},
		function_name = "%s ->",
		terminator = "",
		scr = "",
		start = 1,
		finalize = function( code, name )
			local files = file.Find( "buildr/builds/rim/*.txt", "DATA" )
				code = code:gsub( "RHUD:", "" )
				code = code:gsub( "PaintAvatar", "DrawAvatar" )
				code = code:gsub( "LocalPlayer%(%)", "Player" )
			
			local n = #files
				file.Write( "buildr/builds/rim/" .. name .. ".txt", code )
				file.Write( "rim/" .. name .. ".txt", code )
				RIM:Build( name )
				RHUD:SelectHud( buildr.base.name or "buildr" )
			return "builds/rim/" .. name .. ".txt"
		end
	},
	lua = {
		base = {
			"--[[ '%s' ]]--",
			"--[[ designed by %s, generated by buildr ]]--\n",
			"local uses_avatar = %s",
			lua_base .. "\n%s\n",
			lua_hook,
		},
		function_name = "function HUD:%s()",
		terminator = "end",
		scr = "()",
		start = 1,
		finalize = function( code, name )
			code = code:gsub( "RHUD", "HUD" )
			local struct = { name, "lua", "autorun", "client/" }
			for i = 1, #struct do file.CreateDir( "buildr/builds/lua/" .. table.concat( struct, "/", 1, i ) ) end
			file.Write( "buildr/builds/lua/" .. table.concat( struct, "/" ) .. name .. ".txt", code )
			
			return "builds/lua/" .. name .. "/ - drop into addons/"
		end
	},
}
function buildr.build( format, elements )
	local insert = table.insert
	local hud = formats[format]
	local code = table.Copy( hud.base )
	
	local start = hud.start
	local bname = buildr.base.name or "buildr"
	code[start] = code[start]:format( bname )
	code[start + 1] = code[start + 1]:format( LocalPlayer():Nick() )
	
	local setup = {}
	local init = {}
	local drawables = {}
	local uses_avatar = false
	for z, elem in pairs( elements ) do
		if elem.avatar and not uses_avatar then uses_avatar = true end
		local posx, posy = elem:GetPos()
		local c = elem:GetColor()
		local vars = {
			x = "ScrW" .. hud.scr .. " * " .. posx/ScrW(),
			y =  "ScrH" .. hud.scr .. " * " .. posy/ScrH(),
			color = ("Color( %d, %d, %d, %d )"):format( c.r, c.g, c.b, c.a ),
		}
		
		local elem_code = elem:GetCode()
		for k, line in pairs( elem_code ) do
			elem_code[k] = line:gsub( "%$.-%$", function( match )
				local sub = match:sub( 2, -2 )
				return vars[sub] or elem:GetCodeVar( sub )
			end )
		end
		drawables[z] = table.Copy( elem_code )
		
		local head = elem:GetInitCode()
		for _, line in pairs( head ) do
			line = line:gsub( "%$.-%$", function( match )
				local sub = match:sub( 2, -2 )
				return vars[sub] or elem:GetCodeVar( sub )
			end )
			insert( init, line )
		end
		
		for _, l in pairs( elem:GetSetupCode() ) do insert( setup, l ) end
	end
	
	code[start + 2] = code[start + 2]:format( tostring( uses_avatar ) )
	
	local body = {}
	for _, l in pairs( setup ) do insert( body, l ) end
	insert( body, "\n" )
	insert( body, hud.function_name:format( "Init" ) )
	for _, l in pairs( init ) do insert( body, "\t" .. l ) end
	insert( body, hud.terminator )
	insert( body, "" )
	
	insert( body, hud.function_name:format( "Draw" ) )
	for k, draws in ipairs( drawables ) do
		for _, l in pairs( draws ) do
			insert( body, "\t" .. l ) 
		end
	end
	insert( body, hud.terminator )
	
	body = table.concat( body, "\n" )
	
	body = body:gsub( "|%*", function( match )
		return "\" .. " .. match:sub( 5, -3 )
	end )
	
	body = body:gsub( "%*|", function( match )
		return " .. \""
	end )
	
	code[4] = code[4]:format( body )
	code = table.concat( code, "\n" )
	
	local path = formats[format].finalize( code, bname )
	buildr.save( elements, buildr.base.name, path )
end

function buildr.delete( name, full )
	file.Delete( "buildr/saves/" .. name )
	name = name:gsub( "%.dat$", "" )
	
	if full then
		for _, p in ipairs( { "rim/%s.txt", "rhud/%s.txt", "lua/%s/lua/autorun/client/%s.txt", "lua/%s" } ) do
			file.Delete( "buildr/builds/" .. p:format( name, name ) )
		end
	end
	
	file.Delete( "rim/" .. name .. ".txt" )
	if RIM then RIM.Huds[name] = nil end
	if RHUD then 
		RHUD:SelectHud( "none" )
		RHUD.Huds[name] = nil 
	end
end

function buildr.serialize( tab )
	local new = {}
	for k, v in pairs( tab ) do
		if type( k ) == "Panel" then k = k.id end
		if type( v ) == "Panel" then v = v.id end
		if type( k ) == "table" then k = buildr.serialize( k ) end
		if type( v ) == "table" then v = buildr.serialize( v ) end
		if not k then continue end
		new[k] = v
	end
	return new
end

function buildr.save( elements, name, msg )
	local save = {}
	for id, panel in pairs( elements ) do
		save[id] = { __class = panel.class }
		for var in pairs( panel.SaveVariables ) do
			local set = panel[var]
			if not set then continue end
			if type( set ) == "Panel" then set = set.id end
			if type( set ) == "table" then
				set = buildr.serialize( set )
			end
			save[id][var] = set
		end
		save[id] = util.TableToJSON( save[id] )
	end
	
	save = util.TableToJSON( save )
	file.Write( "buildr/saves/" .. name .. ".dat", save )
	buildr.base:DoSaveEffect( true, msg )
end

function buildr.load( name )
	buildr.base.Working = true
	buildr.base.MenuBar:SetText( name:sub( 1, -5 ) )
	
	local data = file.Read( "buildr/saves/" .. name, "DATA" )

	if not data or not data:find( "." ) then 
		buildr.base:DoSaveEffect( false )
	return end
	
	local tab = util.JSONToTable( data )
	if not tab then buildr.base:DoSaveEffect( false ) return end
	
	local tovars = {}
	for id, json in ipairs( tab ) do
		local vars = util.JSONToTable( json )
		
		local info = buildr.elements[vars.__class]
		if not info then continue end
		
		local pnl = buildr.base:CreateElement( vars.__class, info )
		tovars[pnl] = vars
	end
	
	for pnl, vars in pairs( tovars ) do
		for var, val in pairs( vars ) do
			if var:find( "^__" ) then continue end
			pnl:LoadSavedVar( var, val )
		end
	end
	
	buildr.base.name = name:gsub( "%.dat$", "" )
end